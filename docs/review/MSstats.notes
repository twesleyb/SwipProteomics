# Protein-wise model.
* Mixture ~ an experiment: concatenation of all TMT channels
* TechRepMixture ~ technical replicate of a mixture

Set-up for paired/timecourse experiment:
* 3x Mixture (a TMT experiment)
* TechRepMixture: are there technical replicates within a mixtur? No.
	WT1.Fraction1, WT1.Fraction2 == Biological replicate?

Exp1: Fraction 1-7 [1x WT1, 1x MUT1, 2x SPQC1] Exp1.WT1.F1.ChannelX
Exp2: Fraction 1-7 [1x WT2, 1x MUT2, 2x SPQC2]
Exp3: Fraction 1-7 [1x WT3, 1x MUT3, 2x SPQC3]

* Run : MS run ID [Sample]
* Protein: Protein ID [Accession]
* Abundance: Protein-level summarized abundance [Abundance]
* Channel: Labeling information (126, ... 131) [Channel]
* Condition: Condition (ex. Healthy, Cancer, Time0) [WT|MUT|SPQC]
* BioReplicate: Unique ID for biological subject [WT1,WT2,WT,...]
* TechRepMixture: Unique ID for technical replicate of a mixture [WT.F1?]
* Mixture : Unique ID for TMT mixture [Experiment?]


## Module-level model: mixed linear model with protein random effect



#### MSstats Protein-wise model:
lmerTest utilizes lmer and lme4

full model:
lmerTest::lmer(Abundance ~ 1 + (1|Mixture) + (1|Mixture:TechRepMixture) + Group + (1|Subject:Group:Mixture), data = data)
* Documentation should include 'Charge' as this column is also required.
Minor, but item 'Protein', should be 'ProteinName'.

```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataDoc.R
\docType{data}
\name{quant.pd.msstats}
\alias{quant.pd.msstats}
\title{Example of output from proteinSummarizaiton function}
\format{
A data frame with 100 rows and 8 variables.
}
\usage{
quant.pd.msstats
}
\description{
It is made from \code{\link{input.pd}}.
It is the output of proteinSummarization function.
It should include the required columns as below.
The variables are as follows:
}
\details{
\itemize{
  \item Run : MS run ID
  \item Protein : Protein ID
  \item Abundance: Protein-level summarized abundance
  \item Channel : Labeling information (126, ... 131)
  \item Condition : Condition (ex. Healthy, Cancer, Time0)
  \item BioReplicate : Unique ID for biological subject.
  \item TechRepMixture : Unique ID for technical replicate of one TMT mixture.
  \item Mixture : Unique ID for TMT mixture.
}
}
\examples{
head(quant.pd.msstats)

}
\keyword{datasets}
```


cat << EOF
lmer                 package:lmerTest                  R Documentation


     This function overloads ‘lmer’ from the ‘lme4’-package
     (‘lme4::lmer’) and adds a couple of slots needed for the
     computation of Satterthwaite denominator degrees of freedom. All
     arguments are the same as for ‘lme4::lmer’ and all the usual
     ‘lmer’-methods work.

     lmer(
       formula,
       data = NULL,
       REML = TRUE,
       control = lmerControl(),
       start = NULL,
       verbose = 0L,
       subset,
       weights,
       na.action,
       offset,
       contrasts = NULL,
       devFunOnly = FALSE
     )


 formula: a two-sided linear formula object describing both the
          fixed-effects and random-effects part of the model, with the
          response on the left of a ‘~’ operator and the terms,
          separated by ‘+’ operators, on the right.  Random-effects
          terms are distinguished by vertical bars (‘|’) separating
          expressions for design matrices from grouping factors.  Two
          vertical bars (‘||’) can be used to specify multiple
          uncorrelated random effects for the same grouping variable.
          (Because of the way it is implemented, the ‘||’-syntax _works
          only for design matrices containing numeric (continuous)
          predictors_; to fit models with independent categorical
          effects, see ‘dummy’ or the ‘lmer_alt’ function from the
          ‘afex’ package.)

    data: an optional data frame containing the variables named in
          ‘formula’.  By default the variables are taken from the
          environment from which ‘lmer’ is called. While ‘data’ is
          optional, the package authors _strongly_ recommend its use,
          especially when later applying methods such as ‘update’ and
          ‘drop1’ to the fitted model (_such methods are not guaranteed
          to work properly if ‘data’ is omitted_). If ‘data’ is
          omitted, variables will be taken from the environment of
          ‘formula’ (if specified as a formula) or from the parent
          frame (if specified as a character vector).

    REML: logical scalar - Should the estimates be chosen to optimize
          the REML criterion (as opposed to the log-likelihood)?

 control: a list (of correct class, resulting from ‘lmerControl()’ or
          ‘glmerControl()’ respectively) containing control parameters,
          including the nonlinear optimizer to be used and parameters
          to be passed through to the nonlinear optimizer, see the
          ‘*lmerControl’ documentation for details.

   start: a named ‘list’ of starting values for the parameters in the
          model.  For ‘lmer’ this can be a numeric vector or a list
          with one component named ‘"theta"’.

 verbose: integer scalar.  If ‘> 0’ verbose output is generated during
          the optimization of the parameter estimates.  If ‘> 1’
          verbose output is generated during the individual penalized
          iteratively reweighted least squares (PIRLS) steps.

  subset: an optional expression indicating the subset of the rows of
          ‘data’ that should be used in the fit. This can be a logical
          vector, or a numeric vector indicating which observation
          numbers are to be included, or a character vector of the row
          names to be included.  All observations are included by
          default.

 weights: an optional vector of ‘prior weights’ to be used in the
          fitting process.  Should be ‘NULL’ or a numeric vector.
          Prior ‘weights’ are _not_ normalized or standardized in any
          way.  In particular, the diagonal of the residual covariance
          matrix is the squared residual standard deviation parameter
          ‘sigma’ times the vector of inverse ‘weights’.  Therefore, if
          the ‘weights’ have relatively large magnitudes, then in order
          to compensate, the ‘sigma’ parameter will also need to have a
          relatively large magnitude.

na.action: a function that indicates what should happen when the data
          contain ‘NA’s.  The default action (‘na.omit’, inherited from
          the 'factory fresh' value of ‘getOption("na.action")’) strips
          any observations with any missing values in any variables.

  offset: this can be used to specify an _a priori_ known component to
          be included in the linear predictor during fitting. This
          should be ‘NULL’ or a numeric vector of length equal to the
          number of cases.  One or more ‘offset’ terms can be included
          in the formula instead or as well, and if more than one is
          specified their sum is used.  See ‘model.offset’.

contrasts: an optional list. See the ‘contrasts.arg’ of
          ‘model.matrix.default’.

devFunOnly: logical - return only the deviance evaluation function.
          Note that because the deviance function operates on variables
          stored in its environment, it may not return _exactly_ the
          same values on subsequent calls (but the results should
          always be within machine tolerance).


     For details about ‘lmer’ see ‘lmer’ (‘help(lme4::lmer)’). The
     description of all arguments is taken unedited from the
     ‘lme4’-package.

     In cases when a valid ‘lmer’-object (‘lmerMod’) is produced, but
     when the computations needed for Satterthwaite df fails, the
     ‘lmerMod’ object is returned - not an ‘lmerModLmerTest’ object.


     an S4 object of class ‘"lmerModLmerTest"’


     Rune Haubo B. Christensen and Alexandra Kuznetsova for the
     overload in ‘lmerTest’ - ‘lme4’-authors for the underlying
     implementation in ‘lme4’.


     ‘lmer’ and ‘lmerModLmerTest’


     data("sleepstudy", package="lme4")
     m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
     class(m) # lmerModLmerTest
EOF



DEqMS is developped on top of Limma. However, Limma assumes
same prior variance for all genes. In proteomics, the accuracy
of protein abundance estimates varies by the number of
peptides/PSMs quantified in both label-free and labelled data.
Proteins quantification by multiple peptides or PSMs are more
accurate. DEqMS package is able to estimate different prior
variances for proteins quantified by different number of
PSMs/peptides, therefore acchieving better accuracy. The
package can be applied to analyze both label-free and labelled
proteomics data.


contact this author:
code: https://github.com/gu-mi/NBGOF
